const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const { v4: uuidv4 } = require('uuid');

class Database {
  constructor() {
    this.db = new sqlite3.Database(path.join(__dirname, 'hairstyles.db'));
    this.init();
  }

  init() {
    this.db.serialize(() => {
      // Create users table
      this.db.run(`
        CREATE TABLE IF NOT EXISTS users (
          id TEXT PRIMARY KEY,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          last_active DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `);

      // Create user_favorites table
      this.db.run(`
        CREATE TABLE IF NOT EXISTS user_favorites (
          user_id TEXT NOT NULL,
          hairstyle_id TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          PRIMARY KEY (user_id, hairstyle_id),
          FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
          FOREIGN KEY (hairstyle_id) REFERENCES hairstyles(id) ON DELETE CASCADE
        )
      `);

      // Create indexes for favorites
      this.db.run('CREATE INDEX IF NOT EXISTS idx_user_favorites_user ON user_favorites(user_id)');
      this.db.run('CREATE INDEX IF NOT EXISTS idx_user_favorites_hairstyle ON user_favorites(hairstyle_id)');

      // Create hairstyles table
      this.db.run(`
        CREATE TABLE IF NOT EXISTS hairstyles (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          category TEXT NOT NULL,
          length TEXT NOT NULL,
          texture TEXT NOT NULL,
          face_shapes TEXT NOT NULL,
          style_type TEXT DEFAULT 'Unisex',
          pose TEXT DEFAULT 'Straight-on',
          ethnicity TEXT,
          image_url TEXT NOT NULL,
          artist_name TEXT,
          artist_url TEXT,
          image_data BLOB,
          description TEXT,
          tags TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `);

      // Migration: add ethnicity column if table existed without it, then create indexes, then seed/backfill
      this.db.all(`PRAGMA table_info('hairstyles')`, (err, rows) => {
        if (err) {
          console.error('Error reading table info:', err);
        } else {
          const hasEth = rows.some(r => r.name === 'ethnicity');
          const hasUnsplashId = rows.some(r => r.name === 'unsplash_photo_id');
          const hasArtistName = rows.some(r => r.name === 'artist_name');
          const hasArtistUrl = rows.some(r => r.name === 'artist_url');
          const ensureIndexes = () => {
            // Create indexes for better query performance (run after ensuring columns)
            this.db.run(`CREATE INDEX IF NOT EXISTS idx_category ON hairstyles(category)`);
            this.db.run(`CREATE INDEX IF NOT EXISTS idx_length ON hairstyles(length)`);
            this.db.run(`CREATE INDEX IF NOT EXISTS idx_texture ON hairstyles(texture)`);
            this.db.run(`CREATE INDEX IF NOT EXISTS idx_style_type ON hairstyles(style_type)`);
            this.db.run(`CREATE INDEX IF NOT EXISTS idx_pose ON hairstyles(pose)`);
            this.db.run(`CREATE INDEX IF NOT EXISTS idx_ethnicity ON hairstyles(ethnicity)`);
            this.db.run(`CREATE INDEX IF NOT EXISTS idx_unsplash_photo_id ON hairstyles(unsplash_photo_id)`);
          };

          const runPostMigration = () => {
            // Insert sample data if table is empty and backfill ethnicity on existing rows
            this.db.get("SELECT COUNT(*) as count FROM hairstyles", (err2, row) => {
              if (err2) {
                console.error('Error checking hairstyles count:', err2);
                return;
              }
              if (row.count === 0) {
                this.insertSampleData();
              } else {
                // Backfill ethnicity column if null using name heuristics from our original seed set
                const updates = [
                  { like: '%Classic Bob%', eth: 'Caucasian' },
                  { like: '%Beach Waves%', eth: 'Caucasian' },
                  { like: '%Long Layers%', eth: 'Asian' },
                  { like: '%Pixie Cut%', eth: 'Caucasian' },
                  { like: '%Curly Shag%', eth: 'Afro' },
                  { like: '%Blunt Lob%', eth: 'Caucasian' },
                  { like: '%Braided Crown%', eth: 'Afro' },
                  { like: '%Asymmetrical Bob%', eth: 'Asian' },
                  { like: '%Sleek Straight%', eth: 'Asian' },
                  { like: '%Textured Crop%', eth: 'Caucasian' },
                  { like: '%Voluminous Curls%', eth: 'Afro' },
                  { like: '%Side Swept Bangs%', eth: 'Caucasian' }
                ];
                updates.forEach(u => {
                  this.db.run('UPDATE hairstyles SET ethnicity = COALESCE(ethnicity, ?) WHERE ethnicity IS NULL AND name LIKE ?', [u.eth, u.like]);
                });
              }
            });
          };

          const afterAlters = () => { ensureIndexes(); runPostMigration(); };
          const doEth = (next) => {
            if (!hasEth) {
              this.db.run(`ALTER TABLE hairstyles ADD COLUMN ethnicity TEXT`, (e) => {
                if (e) console.warn('ALTER TABLE add ethnicity failed (may already exist):', e.message);
                next();
              });
            } else next();
          };
          const doUnsplash = (next) => {
            if (!hasUnsplashId) {
              this.db.run(`ALTER TABLE hairstyles ADD COLUMN unsplash_photo_id TEXT`, (e) => {
                if (e) console.warn('ALTER TABLE add unsplash_photo_id failed (may already exist):', e.message);
                next();
              });
            } else next();
          };
          const doArtistName = (next) => {
            if (!hasArtistName) {
              this.db.run(`ALTER TABLE hairstyles ADD COLUMN artist_name TEXT`, (e) => {
                if (e) console.warn('ALTER TABLE add artist_name failed (may already exist):', e.message);
                next();
              });
            } else next();
          };
          const doArtistUrl = (next) => {
            if (!hasArtistUrl) {
              this.db.run(`ALTER TABLE hairstyles ADD COLUMN artist_url TEXT`, (e) => {
                if (e) console.warn('ALTER TABLE add artist_url failed (may already exist):', e.message);
                next();
              });
            } else next();
          };
          doEth(() => doUnsplash(() => doArtistName(() => doArtistUrl(afterAlters))));
        }
      });
    });
  }

  insertSampleData() {
    const sampleHairstyles = [
      {
        name: "Classic Bob",
        category: "Short",
        length: "Short",
        texture: "Straight",
        face_shapes: JSON.stringify(["Oval", "Square"]),
        style_type: "Feminine",
        pose: "Straight-on",
        ethnicity: "Caucasian",
        image_url: "https://images.unsplash.com/photo-1494790108755-2616c96d5e55?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "A timeless short cut that hits just below the chin",
        tags: JSON.stringify(["classic", "professional", "low-maintenance"])
      },
      {
        name: "Beach Waves",
        category: "Medium",
        length: "Medium",
        texture: "Wavy",
        face_shapes: JSON.stringify(["Oval", "Heart", "Round"]),
        style_type: "Feminine",
        pose: "Angled",
        ethnicity: "Caucasian",
        image_url: "https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Effortless wavy style perfect for a casual look",
        tags: JSON.stringify(["casual", "beachy", "textured"])
      },
      {
        name: "Long Layers",
        category: "Long",
        length: "Long",
        texture: "Straight",
        face_shapes: JSON.stringify(["Oval", "Long"]),
        style_type: "Feminine",
        pose: "Side",
        ethnicity: "Asian",
        image_url: "https://images.unsplash.com/photo-1544005313-94ddf0286df2?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Flowing layers that add movement and dimension",
        tags: JSON.stringify(["layered", "voluminous", "elegant"])
      },
      {
        name: "Pixie Cut",
        category: "Short",
        length: "Short",
        texture: "Straight",
        face_shapes: JSON.stringify(["Oval", "Heart"]),
        style_type: "Unisex",
        pose: "Straight-on",
        ethnicity: "Caucasian",
        image_url: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Bold and edgy short cut that's easy to maintain",
        tags: JSON.stringify(["edgy", "bold", "low-maintenance"])
      },
      {
        name: "Curly Shag",
        category: "Medium",
        length: "Medium",
        texture: "Curly",
        face_shapes: JSON.stringify(["Oval", "Round"]),
        style_type: "Feminine",
        pose: "Angled",
        ethnicity: "Afro",
        image_url: "https://images.unsplash.com/photo-1616683693504-3ea7e9ad6fec?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Textured layers that enhance natural curls",
        tags: JSON.stringify(["curly", "textured", "bohemian"])
      },
      {
        name: "Blunt Lob",
        category: "Medium",
        length: "Medium",
        texture: "Straight",
        face_shapes: JSON.stringify(["Oval", "Square"]),
        style_type: "Feminine",
        pose: "Straight-on",
        ethnicity: "Caucasian",
        image_url: "https://images.unsplash.com/photo-1529626455594-4ff0802cfb7e?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "A sleek long bob with clean, straight lines",
        tags: JSON.stringify(["sleek", "modern", "sophisticated"])
      },
      {
        name: "Braided Crown",
        category: "Long",
        length: "Long",
        texture: "Any",
        face_shapes: JSON.stringify(["Oval", "Heart", "Round"]),
        style_type: "Feminine",
        pose: "Angled",
        ethnicity: "Afro",
        image_url: "https://images.unsplash.com/photo-1508214751196-bcfd4ca60f91?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Elegant braided style perfect for special occasions",
        tags: JSON.stringify(["braided", "elegant", "formal"])
      },
      {
        name: "Asymmetrical Bob",
        category: "Short",
        length: "Short",
        texture: "Straight",
        face_shapes: JSON.stringify(["Oval", "Square"]),
        style_type: "Feminine",
        pose: "Side",
        ethnicity: "Asian",
        image_url: "https://images.unsplash.com/photo-1531123897727-8f129e1688ce?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Modern bob with one side longer than the other",
        tags: JSON.stringify(["asymmetrical", "modern", "trendy"])
      },
      {
        name: "Sleek Straight",
        category: "Long",
        length: "Long",
        texture: "Straight",
        face_shapes: JSON.stringify(["Oval", "Heart"]),
        style_type: "Feminine",
        pose: "Straight-on",
        ethnicity: "Asian",
        image_url: "https://images.unsplash.com/photo-1524504388940-b1c1722653e1?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Ultra-smooth straight hair with a glossy finish",
        tags: JSON.stringify(["sleek", "glossy", "elegant"])
      },
      {
        name: "Textured Crop",
        category: "Short",
        length: "Short",
        texture: "Textured",
        face_shapes: JSON.stringify(["Round", "Square"]),
        style_type: "Masculine",
        pose: "Angled",
        ethnicity: "Caucasian",
        image_url: "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Modern textured crop with defined layers",
        tags: JSON.stringify(["textured", "modern", "edgy"])
      },
      {
        name: "Voluminous Curls",
        category: "Medium",
        length: "Medium",
        texture: "Curly",
        face_shapes: JSON.stringify(["Oval", "Long"]),
        style_type: "Masculine",
        pose: "Straight-on",
        ethnicity: "Afro",
        image_url: "https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Full, bouncy curls with natural volume",
        tags: JSON.stringify(["voluminous", "curly", "natural"])
      },
      {
        name: "Side Swept Bangs",
        category: "Medium",
        length: "Medium",
        texture: "Straight",
        face_shapes: JSON.stringify(["Heart", "Long"]),
        style_type: "Feminine",
        pose: "Side",
        ethnicity: "Caucasian",
        image_url: "https://images.unsplash.com/photo-1534528741775-53994a69daeb?w=400&h=500&fit=crop&crop=face,focalpoint&fp-x=0.5&fp-y=0.3",
        description: "Elegant side-swept bangs with shoulder-length hair",
        tags: JSON.stringify(["bangs", "elegant", "sophisticated"])
      }
    ];

    const stmt = this.db.prepare(`
      INSERT INTO hairstyles (id, name, category, length, texture, face_shapes, style_type, pose, ethnicity, image_url, description, tags)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    sampleHairstyles.forEach(style => {
      stmt.run([
        uuidv4(),
        style.name,
        style.category,
        style.length,
        style.texture,
        style.face_shapes,
        style.style_type,
        style.pose,
        style.ethnicity,
        style.image_url,
        style.description,
        style.tags
      ]);
    });

    stmt.finalize();
    console.log('Sample hairstyles data inserted successfully');
  }

  getAllHairstyles(filters = {}) {
    return new Promise((resolve, reject) => {
      let query = 'SELECT * FROM hairstyles WHERE 1=1';
      const params = [];

      // category filter removed from API surface

      if (filters.length) {
        if (Array.isArray(filters.length) && filters.length.length > 0) {
          const placeholders = filters.length.map(() => '?').join(',');
          query += ` AND length IN (${placeholders})`;
          params.push(...filters.length);
        } else if (typeof filters.length === 'string') {
          query += ' AND length = ?';
          params.push(filters.length);
        }
      }

      if (filters.texture) {
        if (Array.isArray(filters.texture) && filters.texture.length > 0) {
          const placeholders = filters.texture.map(() => '?').join(',');
          query += ` AND texture IN (${placeholders})`;
          params.push(...filters.texture);
        } else if (typeof filters.texture === 'string') {
          query += ' AND texture = ?';
          params.push(filters.texture);
        }
      }

      if (filters.face_shape) {
        if (Array.isArray(filters.face_shape) && filters.face_shape.length > 0) {
          const ors = filters.face_shape.map(() => 'face_shapes LIKE ?').join(' OR ');
          query += ` AND (${ors})`;
          filters.face_shape.forEach(v => params.push(`%"${v}"%`));
        } else if (typeof filters.face_shape === 'string') {
          query += ' AND face_shapes LIKE ?';
          params.push(`%"${filters.face_shape}"%`);
        }
      }

      if (filters.style_type) {
        if (Array.isArray(filters.style_type) && filters.style_type.length > 0) {
          const placeholders = filters.style_type.map(() => '?').join(',');
          query += ` AND style_type IN (${placeholders})`;
          params.push(...filters.style_type);
        } else if (typeof filters.style_type === 'string') {
          query += ' AND style_type = ?';
          params.push(filters.style_type);
        }
      }

      if (filters.pose) {
        if (Array.isArray(filters.pose) && filters.pose.length > 0) {
          const placeholders = filters.pose.map(() => '?').join(',');
          query += ` AND pose IN (${placeholders})`;
          params.push(...filters.pose);
        } else if (typeof filters.pose === 'string') {
          query += ' AND pose = ?';
          params.push(filters.pose);
        }
      }

      if (filters.ethnicity) {
        if (Array.isArray(filters.ethnicity) && filters.ethnicity.length > 0) {
          const placeholders = filters.ethnicity.map(() => '?').join(',');
          query += ` AND ethnicity IN (${placeholders})`;
          params.push(...filters.ethnicity);
        } else if (typeof filters.ethnicity === 'string') {
          query += ' AND ethnicity = ?';
          params.push(filters.ethnicity);
        }
      }

      if (filters.search) {
        query += ' AND (name LIKE ? OR description LIKE ? OR tags LIKE ?)';
        const searchTerm = `%${filters.search}%`;
        params.push(searchTerm, searchTerm, searchTerm);
      }

      query += ' ORDER BY created_at DESC';

      this.db.all(query, params, (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // Parse JSON fields
          const hairstyles = rows.map(row => ({
            ...row,
            face_shapes: JSON.parse(row.face_shapes),
            tags: JSON.parse(row.tags || '[]')
          }));
          resolve(hairstyles);
        }
      });
    });
  }

  getHairstyleById(id) {
    return new Promise((resolve, reject) => {
      this.db.get('SELECT * FROM hairstyles WHERE id = ?', [id], (err, row) => {
        if (err) {
          reject(err);
        } else if (row) {
          resolve({
            ...row,
            face_shapes: JSON.parse(row.face_shapes),
            tags: JSON.parse(row.tags || '[]')
          });
        } else {
          resolve(null);
        }
      });
    });
  }

  addHairstyle(hairstyle) {
    return new Promise((resolve, reject) => {
      const id = uuidv4();
      const stmt = this.db.prepare(`
        INSERT INTO hairstyles (id, name, category, length, texture, face_shapes, style_type, pose, ethnicity, image_url, image_data, description, tags)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      stmt.run([
        id,
        hairstyle.name,
        hairstyle.category,
        hairstyle.length,
        hairstyle.texture,
        JSON.stringify(hairstyle.face_shapes),
        hairstyle.style_type || 'Unisex',
        hairstyle.pose || 'Straight-on',
        hairstyle.ethnicity || null,
        hairstyle.image_url,
        hairstyle.image_data || null,
        hairstyle.description,
        JSON.stringify(hairstyle.tags || [])
      ], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ id, ...hairstyle });
        }
      });

      stmt.finalize();
    });
  }

  getFilters() {
    return new Promise((resolve, reject) => {
      const queries = [
        'SELECT DISTINCT length FROM hairstyles ORDER BY length',
        'SELECT DISTINCT texture FROM hairstyles ORDER BY texture',
        'SELECT DISTINCT style_type FROM hairstyles ORDER BY style_type',
        'SELECT DISTINCT pose FROM hairstyles ORDER BY pose',
        'SELECT face_shapes FROM hairstyles',
        // ethnicity may be null if not set
        'SELECT DISTINCT ethnicity FROM hairstyles WHERE ethnicity IS NOT NULL ORDER BY ethnicity'
      ];

      Promise.all(queries.map(query => 
        new Promise((res, rej) => {
          this.db.all(query, (err, rows) => {
            if (err) rej(err);
            else res(rows);
          });
        })
      )).then(results => {
        const [lengths, textures, styleTypes, poses, faceShapesRows, ethnicitiesRows] = results;
        
        // Extract unique face shapes from JSON arrays
        const faceShapesSet = new Set();
        faceShapesRows.forEach(row => {
          const shapes = JSON.parse(row.face_shapes);
          shapes.forEach(shape => faceShapesSet.add(shape));
        });

        const ethnicities = (ethnicitiesRows || []).map(row => row.ethnicity).filter(Boolean);
        resolve({
          lengths: lengths.map(row => row.length),
          textures: textures.map(row => row.texture),
          style_types: styleTypes.map(row => row.style_type),
          poses: poses.map(row => row.pose),
          face_shapes: Array.from(faceShapesSet).sort(),
          ethnicities: ethnicities.length > 0 ? ethnicities : ['Caucasian','Asian','Afro']
        });
      }).catch(reject);
    });
  }

  updateHairstyleEthnicity(id, ethnicity) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE hairstyles SET ethnicity = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        [ethnicity || null, id],
        function (err) {
          if (err) return reject(err);
          resolve({ updated: this.changes > 0 });
        }
      );
    });
  }

  updateImageUrl(id, image_url) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE hairstyles SET image_url = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        [image_url, id],
        function (err) {
          if (err) return reject(err);
          resolve({ updated: this.changes > 0 });
        }
      );
    });
  }

  updateImageAndUnsplashId(id, image_url, unsplash_photo_id) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE hairstyles SET image_url = ?, unsplash_photo_id = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        [image_url, unsplash_photo_id || null, id],
        function (err) {
          if (err) return reject(err);
          resolve({ updated: this.changes > 0 });
        }
      );
    });
  }

  close() {
    this.db.close();
  }

  // User Favorites Methods

  // Get or create a user
  getOrCreateUser(userId, callback) {
    this.db.serialize(() => {
      // First try to get the user
      this.db.get('SELECT * FROM users WHERE id = ?', [userId], (err, row) => {
        if (err) return callback(err);
        
        if (row) {
          // Update last_active for existing user
          this.db.run(
            'UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE id = ?',
            [userId],
            (err) => {
              if (err) return callback(err);
              callback(null, { id: userId });
            }
          );
        } else {
          // Create new user
          this.db.run(
            'INSERT INTO users (id) VALUES (?)',
            [userId],
            function(err) {
              if (err) return callback(err);
              callback(null, { id: userId });
            }
          );
        }
      });
    });
  }

  // Get user's favorite hairstyles
  getUserFavorites(userId, callback) {
    this.db.all(
      `SELECT h.* 
       FROM hairstyles h
       JOIN user_favorites uf ON h.id = uf.hairstyle_id
       WHERE uf.user_id = ?
       ORDER BY uf.created_at DESC`,
      [userId],
      (err, rows) => {
        if (err) return callback(err);
        callback(null, rows || []);
      }
    );
  }

  // Add hairstyle to user's favorites
  addFavorite(userId, hairstyleId, callback) {
    this.db.serialize(() => {
      // First ensure the user exists
      this.getOrCreateUser(userId, (err) => {
        if (err) return callback(err);
        
        // Check if already favorited
        this.db.get(
          'SELECT 1 FROM user_favorites WHERE user_id = ? AND hairstyle_id = ?',
          [userId, hairstyleId],
          (err, row) => {
            if (err) return callback(err);
            
            if (row) {
              // Already favorited
              return callback(null, false);
            }
            
            // Add to favorites
            this.db.run(
              'INSERT INTO user_favorites (user_id, hairstyle_id) VALUES (?, ?)',
              [userId, hairstyleId],
              function(err) {
                if (err) return callback(err);
                callback(null, true);
              }
            );
          }
        );
      });
    });
  }

  // Remove hairstyle from user's favorites
  removeFavorite(userId, hairstyleId, callback) {
    this.db.run(
      'DELETE FROM user_favorites WHERE user_id = ? AND hairstyle_id = ?',
      [userId, hairstyleId],
      function(err) {
        if (err) return callback(err);
        callback(null, this.changes > 0);
      }
    );
  }

  // Check if a hairstyle is favorited by user
  isFavorite(userId, hairstyleId, callback) {
    this.db.get(
      'SELECT 1 FROM user_favorites WHERE user_id = ? AND hairstyle_id = ?',
      [userId, hairstyleId],
      (err, row) => {
        if (err) return callback(err);
        callback(null, !!row);
      }
    );
  }
}
          // Create new user
          this.db.run(
            'INSERT INTO users (id) VALUES (?)',
            [userId],
            function(err) {
              if (err) return callback(err);
              callback(null, { id: userId });
            }
          );
        }
      });
    });
  }

  // Get user's favorite hairstyles
  getUserFavorites(userId, callback) {
    this.db.all(
      `SELECT h.* 
       FROM hairstyles h
       JOIN user_favorites uf ON h.id = uf.hairstyle_id
       WHERE uf.user_id = ?
       ORDER BY uf.created_at DESC`,
      [userId],
      (err, rows) => {
        if (err) return callback(err);
        callback(null, rows || []);
      }
    );
  }

  // Add hairstyle to user's favorites
  addFavorite(userId, hairstyleId, callback) {
    this.db.serialize(() => {
      // First ensure the user exists
      this.getOrCreateUser(userId, (err) => {
        if (err) return callback(err);
        
        // Check if already favorited
        this.db.get(
          'SELECT 1 FROM user_favorites WHERE user_id = ? AND hairstyle_id = ?',
          [userId, hairstyleId],
          (err, row) => {
            if (err) return callback(err);
            
            if (row) {
              // Already favorited
              return callback(null, false);
            }
            
            // Add to favorites
            this.db.run(
              'INSERT INTO user_favorites (user_id, hairstyle_id) VALUES (?, ?)',
              [userId, hairstyleId],
              function(err) {
                if (err) return callback(err);
                callback(null, true);
              }
            );
          }
        );
      });
    });
  }

  // Remove hairstyle from user's favorites
  removeFavorite(userId, hairstyleId, callback) {
    this.db.run(
      'DELETE FROM user_favorites WHERE user_id = ? AND hairstyle_id = ?',
      [userId, hairstyleId],
      function(err) {
        if (err) return callback(err);
        callback(null, this.changes > 0);
      }
    );
  }

  // Check if a hairstyle is favorited by user
  isFavorite(userId, hairstyleId, callback) {
    this.db.get(
      'SELECT 1 FROM user_favorites WHERE user_id = ? AND hairstyle_id = ?',
      [userId, hairstyleId],
      (err, row) => {
        if (err) return callback(err);
        callback(null, !!row);
      }
    );
  }
}

module.exports = Database;
